"""
API Audit Router - Endpoints for API discovery and OpenAPI management.
"""
from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import Response
from sqlalchemy.orm import Session
from typing import List, Optional
from pydantic import BaseModel
from datetime import datetime

from ..database import get_db
from .. import models

router = APIRouter(
    prefix="/projects",
    tags=["api-audit"]
)


# =============================================================================
# Response Models
# =============================================================================

class APIEndpointResponse(BaseModel):
    id: str
    endpoint_url: str
    http_method: Optional[str]
    direction: str
    auth_method: Optional[str]
    file_path: Optional[str]
    line_number: Optional[int]
    code_snippet: Optional[str]
    framework: Optional[str]
    confidence: Optional[str]
    
    model_config = {"from_attributes": True}


class APIAuditSummary(BaseModel):
    total_endpoints: int
    serves_count: int
    outbound_count: int
    auth_methods: dict  # {"bearer": 5, "api-key": 3, ...}
    frameworks: dict  # {"fastapi": 10, "express": 2, ...}
    has_openapi_spec: bool
    

class OpenAPISpecResponse(BaseModel):
    spec_content: str
    spec_format: str
    version: str
    endpoint_count: int
    generated_at: datetime
    

# =============================================================================
# Endpoints
# =============================================================================

@router.get("/{project_id}/api-audit/matched-credentials")
async def get_matched_credentials(project_id: str, server_url: str = None, db: Session = Depends(get_db)):
    """
    Get AI-matched credentials with certainty scores.
    Returns credentials matched to their likely target services.
    """
    import sys
    sys.path.insert(0, '/app/execution')
    from ai_credential_matcher import match_credentials_with_llm
    
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    reports_dir = os.environ.get("REPORTS_DIR", "/app/vulnerability_reports")
    
    try:
        matched = await match_credentials_with_llm(project.name, server_url, reports_dir)
        return {
            "success": True,
            "credentials": matched,
            "total": len(matched),
            "high_confidence": len([m for m in matched if m['certainty'] >= 80])
        }
    except Exception as e:
        return {"success": False, "error": str(e), "credentials": []}

@router.get("/{project_id}/api-audit/swagger-files")
def list_swagger_files(project_id: str, db: Session = Depends(get_db)):
    """
    List all available swagger files for a project.
    Returns per-server swagger specs generated by AI discovery.
    """
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    reports_dir = os.environ.get("REPORTS_DIR", "/app/vulnerability_reports")
    project_dir = os.path.join(reports_dir, project.name)
    
    swagger_files = []
    
    if os.path.exists(project_dir):
        for filename in os.listdir(project_dir):
            if filename.endswith('_swagger.yaml'):
                base_name = filename.replace('_swagger.yaml', '')
                json_file = f"{base_name}_swagger.json"
                yaml_path = os.path.join(project_dir, filename)
                json_path = os.path.join(project_dir, json_file)
                
                # Extract server info from the YAML
                server_url = ""
                path_count = 0
                try:
                    with open(yaml_path, 'r') as f:
                        spec = yaml.safe_load(f)
                        servers = spec.get('servers', [])
                        if servers:
                            server_url = servers[0].get('url', '')
                        path_count = len(spec.get('paths', {}))
                except:
                    pass
                
                swagger_files.append({
                    'name': base_name,
                    'server_url': server_url,
                    'yaml_file': filename,
                    'json_file': json_file if os.path.exists(json_path) else None,
                    'path_count': path_count
                })
    
    return {"files": swagger_files, "count": len(swagger_files)}


@router.get("/{project_id}/api-audit/swagger-file/{filename}")
def download_swagger_file(project_id: str, filename: str, db: Session = Depends(get_db)):
    """
    Download a specific swagger file.
    """
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    reports_dir = os.environ.get("REPORTS_DIR", "/app/vulnerability_reports")
    file_path = os.path.join(reports_dir, project.name, filename)
    
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="File not found")
    
    # Determine content type
    if filename.endswith('.json'):
        media_type = "application/json"
    elif filename.endswith('.yaml') or filename.endswith('.yml'):
        media_type = "application/x-yaml"
    else:
        media_type = "application/octet-stream"
    
    with open(file_path, 'r') as f:
        content = f.read()
    
    return Response(
        content=content,
        media_type=media_type,
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )


@router.get("/{project_id}/api-audit", response_model=List[APIEndpointResponse])
def get_project_api_endpoints(project_id: str, db: Session = Depends(get_db)):
    """Get all discovered API endpoints for a project."""
    # Verify project exists
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    endpoints = db.query(models.APIEndpoint).filter(
        models.APIEndpoint.repository_id == project_id
    ).order_by(
        models.APIEndpoint.direction,
        models.APIEndpoint.endpoint_url
    ).all()
    
    return [
        APIEndpointResponse(
            id=str(ep.id),
            endpoint_url=ep.endpoint_url,
            http_method=ep.http_method,
            direction=ep.direction,
            auth_method=ep.auth_method,
            file_path=ep.file_path,
            line_number=ep.line_number,
            code_snippet=ep.code_snippet,
            framework=ep.framework,
            confidence=ep.confidence
        )
        for ep in endpoints
    ]


@router.get("/{project_id}/api-audit/summary", response_model=APIAuditSummary)
def get_project_api_summary(project_id: str, db: Session = Depends(get_db)):
    """Get summary statistics for API audit."""
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    endpoints = db.query(models.APIEndpoint).filter(
        models.APIEndpoint.repository_id == project_id
    ).all()
    
    # Count by direction
    serves_count = sum(1 for ep in endpoints if ep.direction == 'serves')
    outbound_count = sum(1 for ep in endpoints if ep.direction == 'outbound')
    
    # Count by auth method
    auth_methods = {}
    for ep in endpoints:
        method = ep.auth_method or 'none'
        auth_methods[method] = auth_methods.get(method, 0) + 1
    
    # Count by framework
    frameworks = {}
    for ep in endpoints:
        fw = ep.framework or 'unknown'
        frameworks[fw] = frameworks.get(fw, 0) + 1
    
    # Check for OpenAPI spec
    has_spec = db.query(models.OpenAPISpec).filter(
        models.OpenAPISpec.repository_id == project_id
    ).first() is not None
    
    return APIAuditSummary(
        total_endpoints=len(endpoints),
        serves_count=serves_count,
        outbound_count=outbound_count,
        auth_methods=auth_methods,
        frameworks=frameworks,
        has_openapi_spec=has_spec
    )


@router.get("/{project_id}/api-audit/openapi")
def get_project_openapi_spec(
    project_id: str, 
    format: str = "yaml",
    db: Session = Depends(get_db)
):
    """Get the OpenAPI specification for a project."""
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    spec = db.query(models.OpenAPISpec).filter(
        models.OpenAPISpec.repository_id == project_id
    ).first()
    
    if not spec:
        raise HTTPException(status_code=404, detail="OpenAPI specification not found. Run API audit scan first.")
    
    # Return appropriate content type based on format
    if format == "json":
        return Response(
            content=spec.spec_content,
            media_type="application/json",
            headers={
                "Content-Disposition": f'attachment; filename="{project.name}_openapi.json"'
            }
        )
    else:
        return Response(
            content=spec.spec_content,
            media_type="application/x-yaml",
            headers={
                "Content-Disposition": f'attachment; filename="{project.name}_openapi.yaml"'
            }
        )


from fastapi.responses import HTMLResponse

@router.get("/{project_id}/api-audit/swagger", response_class=HTMLResponse)
def get_project_swagger_ui(project_id: str, spec_url: str = None, db: Session = Depends(get_db)):
    """
    Serve a local SwaggerUI page that loads the project's OpenAPI spec.
    Optionally accepts spec_url to load a specific swagger file.
    Automatically injects discovered credentials for authenticated API testing.
    """
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Load discovered credentials from endpoints file
    reports_dir = os.environ.get("REPORTS_DIR", "/app/vulnerability_reports")
    endpoints_file = os.path.join(reports_dir, project.name, f"{project.name}_api_endpoints.json")
    
    credentials = []
    if os.path.exists(endpoints_file):
        try:
            with open(endpoints_file, 'r') as f:
                data = json.load(f)
            
            for ep in data.get('outbound_endpoints', []):
                secret_type = ep.get('metadata', {}).get('secret_type', '')
                if not secret_type or secret_type == 'api_url':
                    continue
                
                # Extract the actual credential value from the code
                code = ep.get('code', '')
                value = ''
                
                # Parse the credential value from different formats
                if '=' in code:
                    parts = code.split('=', 1)
                    if len(parts) > 1:
                        value = parts[1].strip().strip('"').strip("'")
                elif ':' in code:
                    parts = code.split(':', 1)
                    if len(parts) > 1:
                        value = parts[1].strip().strip('"').strip("'")
                
                if value:
                    credentials.append({
                        'type': secret_type,
                        'name': ep.get('metadata', {}).get('key_name', secret_type),
                        'value': value[:100],  # Truncate for safety
                        'environment': ep.get('metadata', {}).get('environment', 'unknown'),
                        'file': os.path.basename(ep.get('path', '')),
                        'category': _classify_credential_type(secret_type)
                    })
        except Exception as e:
            print(f"Error loading credentials: {e}")
    
    # Group credentials by category for the selector
    cred_groups = {}
    for cred in credentials:
        cat = cred['category']
        if cat not in cred_groups:
            cred_groups[cat] = []
        cred_groups[cat].append(cred)
    
    # Generate credentials JSON for JavaScript
    creds_json = json.dumps(credentials)
    
    # Generate SwaggerUI HTML page with credential selector
    html_content = f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Audit - {project.name} - SwaggerUI</title>
    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui.css" />
    <style>
        body {{
            margin: 0;
            padding: 0;
            background: #000 !important;
        }}
        /* Force ALL text to be white/bright */
        .swagger-ui,
        .swagger-ui * {{
            color: #fff !important;
        }}
        .swagger-ui .topbar {{
            display: none;
        }}
        .swagger-ui {{
            max-width: 1400px;
            margin: 0 auto;
        }}
        .swagger-ui,
        .swagger-ui .opblock-tag,
        .swagger-ui .opblock-tag small,
        .swagger-ui .opblock-description-wrapper p,
        .swagger-ui .opblock-external-docs-wrapper p,
        .swagger-ui .opblock-title_normal p,
        .swagger-ui table thead tr th,
        .swagger-ui table thead tr td,
        .swagger-ui .response-col_status,
        .swagger-ui .response-col_links,
        .swagger-ui .response-col_description,
        .swagger-ui .responses-inner h4,
        .swagger-ui .responses-inner h5,
        .swagger-ui .opblock .opblock-section-header h4,
        .swagger-ui .parameter__name,
        .swagger-ui .parameter__type,
        .swagger-ui .parameter__deprecated,
        .swagger-ui .parameter__in,
        .swagger-ui label,
        .swagger-ui .btn,
        .swagger-ui select,
        .swagger-ui input,
        .swagger-ui .model-title,
        .swagger-ui section.models h4,
        .swagger-ui .model,
        .swagger-ui .renderedMarkdown p {{
            color: #e0e0e0 !important;
        }}
        .swagger-ui .opblock {{
            background: #1a1a1a !important;
            border-color: #333 !important;
        }}
        .swagger-ui .opblock .opblock-summary {{
            border-color: #333 !important;
        }}
        .swagger-ui .opblock .opblock-section-header {{
            background: #222 !important;
            border-color: #333 !important;
        }}
        .swagger-ui .opblock-body pre {{
            background: #111 !important;
            color: #e0e0e0 !important;
        }}
        .swagger-ui .responses-table {{
            background: #1a1a1a !important;
        }}
        .swagger-ui .model-box {{
            background: #1a1a1a !important;
        }}
        .swagger-ui .info {{
            background: transparent !important;
        }}
        .swagger-ui .info .title,
        .swagger-ui .info .title small {{
            color: #fff !important;
        }}
        .swagger-ui .scheme-container {{
            background: #111 !important;
            box-shadow: none !important;
        }}
        .swagger-ui .filter .operation-filter-input {{
            background: #1a1a1a !important;
            color: #fff !important;
            border-color: #333 !important;
        }}
        .swagger-ui section.models {{
            background: #0a0a0a !important;
            border-color: #333 !important;
        }}
        .swagger-ui .model-container {{
            background: #111 !important;
        }}
        .swagger-ui textarea {{
            background: #1a1a1a !important;
            color: #e0e0e0 !important;
            border-color: #333 !important;
        }}
        .swagger-ui select {{
            background: #1a1a1a !important;
            border-color: #333 !important;
        }}
        .swagger-ui .microlight {{
            background: #111 !important;
        }}
        .header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }}
        .header h1 {{
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            font-size: 1.5rem;
        }}
        .header .subtitle {{
            opacity: 0.8;
            font-size: 0.9rem;
            margin-top: 4px;
        }}
        .back-btn {{
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            text-decoration: none;
        }}
        .back-btn:hover {{
            background: rgba(255,255,255,0.3);
        }}
        .auth-bar {{
            background: #2a2a4e;
            padding: 15px 40px;
            border-bottom: 1px solid #3a3a6e;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }}
        .auth-bar-title {{
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }}
        .auth-select {{
            background: #1a1a2e;
            border: 1px solid #4a4a7e;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            min-width: 180px;
            cursor: pointer;
        }}
        .auth-input {{
            background: #1a1a2e;
            border: 1px solid #4a4a7e;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            min-width: 350px;
            font-family: monospace;
        }}
        .auth-input:focus, .auth-select:focus {{
            outline: none;
            border-color: #667eea;
        }}
        .auth-status {{
            color: #10b981;
            font-size: 12px;
            margin-left: auto;
        }}
        .auth-status.inactive {{
            color: #6b7280;
        }}
        .auth-btn {{
            background: #667eea;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
        }}
        .auth-btn:hover {{
            background: #5a6fd6;
        }}
        .auth-btn.clear {{
            background: #4a4a7e;
        }}
    </style>
</head>
<body>
    <div class="header">
        <div>
            <h1>üîç API Audit - {project.name}</h1>
            <div class="subtitle">Interactive API Explorer powered by SwaggerUI</div>
        </div>
        <a href="javascript:history.back()" class="back-btn">‚Üê Back to Dashboard</a>
    </div>
    
    <div class="auth-bar">
        <div class="auth-bar-title">üîê Authentication</div>
        <select id="authType" class="auth-select">
            <option value="">No Authentication</option>
            <option value="subscription">Azure Subscription Key</option>
            <option value="apikey">API Key (X-API-Key)</option>
            <option value="bearer">Bearer Token</option>
            <option value="basic">Basic Auth (user:pass)</option>
            <option value="custom">Custom Header</option>
        </select>
        <input type="text" id="authValue" class="auth-input" placeholder="Enter credential value..." />
        <input type="text" id="customHeader" class="auth-input" placeholder="Header name (e.g. X-Custom-Auth)" style="display:none; min-width:200px;" />
        <button class="auth-btn" onclick="applyAuth()">Apply</button>
        <button class="auth-btn clear" onclick="clearAuth()">Clear</button>
        <div id="authStatus" class="auth-status inactive">No credentials applied</div>
    </div>
    
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-bundle.js"></script>
    <script>
        // Active credentials
        let activeAuth = {{ type: null, value: null, header: null }};
        
        // Show/hide custom header input
        document.getElementById('authType').addEventListener('change', function() {{
            const customHeaderInput = document.getElementById('customHeader');
            const valueInput = document.getElementById('authValue');
            if (this.value === 'custom') {{
                customHeaderInput.style.display = 'block';
                valueInput.placeholder = 'Header value...';
            }} else {{
                customHeaderInput.style.display = 'none';
                if (this.value === 'subscription') {{
                    valueInput.placeholder = 'Enter Ocp-Apim-Subscription-Key...';
                }} else if (this.value === 'apikey') {{
                    valueInput.placeholder = 'Enter API Key...';
                }} else if (this.value === 'bearer') {{
                    valueInput.placeholder = 'Enter Bearer Token (without Bearer prefix)...';
                }} else if (this.value === 'basic') {{
                    valueInput.placeholder = 'Enter username:password...';
                }} else {{
                    valueInput.placeholder = 'Enter credential value...';
                }}
            }}
        }});
        
        function applyAuth() {{
            const type = document.getElementById('authType').value;
            const value = document.getElementById('authValue').value.trim();
            const customHeader = document.getElementById('customHeader').value.trim();
            
            if (!type || !value) {{
                alert('Please select an auth type and enter a value');
                return;
            }}
            
            activeAuth = {{ type: type, value: value, header: customHeader }};
            
            const status = document.getElementById('authStatus');
            status.className = 'auth-status';
            const labels = {{
                'subscription': 'Azure Subscription Key',
                'apikey': 'API Key',
                'bearer': 'Bearer Token',
                'basic': 'Basic Auth',
                'custom': customHeader || 'Custom Header'
            }};
            status.innerHTML = '‚úì ' + labels[type] + ' applied';
        }}
        
        function clearAuth() {{
            activeAuth = {{ type: null, value: null, header: null }};
            document.getElementById('authValue').value = '';
            document.getElementById('customHeader').value = '';
            const status = document.getElementById('authStatus');
            status.className = 'auth-status inactive';
            status.innerHTML = 'No credentials applied';
        }}
        
        // Initialize SwaggerUI with credential injection
        window.onload = function() {{
            const specUrl = "{spec_url if spec_url else f'/projects/{project_id}/api-audit/openapi?format=json'}";
            SwaggerUIBundle({{
                url: specUrl,
                dom_id: '#swagger-ui',
                deepLinking: true,
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIBundle.SwaggerUIStandalonePreset
                ],
                layout: "BaseLayout",
                defaultModelsExpandDepth: -1,
                docExpansion: "list",
                filter: true,
                tryItOutEnabled: true,
                
                // Inject credentials into requests
                requestInterceptor: function(request) {{
                    if (activeAuth.type && activeAuth.value) {{
                        switch (activeAuth.type) {{
                            case 'subscription':
                                request.headers['Ocp-Apim-Subscription-Key'] = activeAuth.value;
                                break;
                            case 'apikey':
                                request.headers['X-API-Key'] = activeAuth.value;
                                request.headers['api-key'] = activeAuth.value;
                                break;
                            case 'bearer':
                                request.headers['Authorization'] = 'Bearer ' + activeAuth.value;
                                break;
                            case 'basic':
                                request.headers['Authorization'] = 'Basic ' + btoa(activeAuth.value);
                                break;
                            case 'custom':
                                if (activeAuth.header) {{
                                    request.headers[activeAuth.header] = activeAuth.value;
                                }}
                                break;
                        }}
                    }}
                    return request;
                }}
            }});
        }};
    </script>
</body>
</html>'''
    
    return HTMLResponse(content=html_content)


def _classify_credential_type(secret_type: str) -> str:
    """Classify credential type for UI grouping."""
    st = secret_type.lower()
    if 'azure' in st or 'subscription' in st:
        return 'Azure API'
    elif 'mixpanel' in st:
        return 'Mixpanel'
    elif 'firebase' in st:
        return 'Firebase'
    elif 'instabug' in st:
        return 'Instabug'
    elif 'cognito' in st:
        return 'AWS Cognito'
    elif 'box' in st:
        return 'Box API'
    elif 'github' in st:
        return 'GitHub'
    elif 'bearer' in st or 'token' in st:
        return 'Bearer Token'
    elif 'api_key' in st or 'apikey' in st:
        return 'API Key'
    else:
        return 'Other'


def _match_credential_to_server(credential: dict, server_url: str) -> bool:
    """Match a credential to a server based on environment and URL patterns."""
    cred_env = credential.get('environment', '').lower()
    url_lower = server_url.lower()
    
    # Direct environment matching
    if 'prod' in cred_env and ('api.' in url_lower or '/prod' in url_lower):
        return True
    if 'stage' in cred_env and 'stage' in url_lower:
        return True
    if 'test' in cred_env and 'test' in url_lower:
        return True
    if any(x in cred_env for x in ['dev', 'qa', 'circle']) and any(x in url_lower for x in ['dev', 'qa', 'circle']):
        return True
    
    # Azure API matching
    if 'azure' in credential.get('type', '').lower() and 'azure' in url_lower:
        return True
    
    # Cognito/ECIM matching
    if 'cognito' in cred_env and 'ecim' in url_lower:
        return True
    
    # EDP matching
    if 'edp' in cred_env and ('azure-api.net' in url_lower or 'edp' in url_lower):
        return True
    
    # SleepIQ matching
    if 'sleepiq' in cred_env and 'sleepiq' in url_lower:
        return True
    
    return False


@router.get("/{project_id}/api-audit/server-testing", response_class=HTMLResponse)
def get_server_testing_ui(project_id: str, db: Session = Depends(get_db)):
    """
    Server Testing UI - Clean table layout with modal-based AI discovery.
    """
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Load data from files
    reports_dir = os.environ.get("REPORTS_DIR", "/app/vulnerability_reports")
    openapi_file = os.path.join(reports_dir, project.name, f"{project.name}_openapi.yaml")
    
    servers = []
    
    # Load servers from OpenAPI
    if os.path.exists(openapi_file):
        try:
            with open(openapi_file, 'r') as f:
                spec = yaml.safe_load(f)
                for s in spec.get('servers', []):
                    servers.append(s.get('url', ''))
        except:
            pass
    
    servers_json = json.dumps(servers[:30])  # Limit to 30 servers
    
    html_content = f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Discovery - {project.name}</title>
    <style>
        * {{ box-sizing: border-box; }}
        body {{
            margin: 0;
            padding: 0;
            background: #0f0f1e;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            color: #e0e0e0;
        }}
        .header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }}
        .header h1 {{ margin: 0; font-size: 1.4rem; }}
        .header .subtitle {{ opacity: 0.85; font-size: 0.85rem; margin-top: 4px; }}
        .back-btn {{
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            text-decoration: none;
            font-size: 13px;
        }}
        .container {{ padding: 30px 40px; max-width: 1400px; margin: 0 auto; }}
        
        /* Table */
        .server-table {{
            width: 100%;
            border-collapse: collapse;
            background: #1a1a2e;
            border-radius: 12px;
            overflow: hidden;
        }}
        .server-table th {{
            background: #22223a;
            padding: 16px 20px;
            text-align: left;
            font-weight: 600;
            color: #a0a0c0;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }}
        .server-table td {{
            padding: 14px 20px;
            border-bottom: 1px solid #2a2a4e;
        }}
        .server-table tr:last-child td {{ border-bottom: none; }}
        .server-table tr:hover {{ background: #22223a; }}
        
        .server-url {{
            font-family: monospace;
            font-size: 13px;
            color: #60a5fa;
        }}
        
        .level-select {{
            background: #0f0f1e;
            color: white;
            border: 1px solid #4a4a7e;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
        }}
        
        .discover-btn {{
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }}
        .discover-btn:hover {{ opacity: 0.9; }}
        .discover-btn:disabled {{ opacity: 0.5; cursor: not-allowed; }}
        
        /* Modal */
        .modal-overlay {{
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }}
        .modal-overlay.active {{ display: flex; }}
        
        .modal {{
            background: #1a1a2e;
            border-radius: 16px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }}
        .modal-header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 24px;
        }}
        .modal-header h2 {{ margin: 0; font-size: 1.1rem; }}
        .modal-header .server {{ opacity: 0.85; font-size: 12px; font-family: monospace; margin-top: 6px; }}
        
        .modal-body {{
            padding: 24px;
            max-height: 50vh;
            overflow-y: auto;
        }}
        
        .progress-section {{
            text-align: center;
            padding: 40px 20px;
        }}
        .spinner {{
            width: 50px;
            height: 50px;
            border: 4px solid #2a2a4e;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }}
        @keyframes spin {{ to {{ transform: rotate(360deg); }} }}
        .progress-text {{ color: #a0a0c0; font-size: 14px; }}
        
        .results-table {{
            width: 100%;
            border-collapse: collapse;
        }}
        .results-table th {{
            background: #22223a;
            padding: 12px 16px;
            text-align: left;
            font-size: 11px;
            text-transform: uppercase;
            color: #a0a0c0;
        }}
        .results-table td {{
            padding: 10px 16px;
            border-bottom: 1px solid #2a2a4e;
            font-size: 13px;
        }}
        .method-badge {{
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            min-width: 50px;
            text-align: center;
        }}
        .method-badge.get {{ background: #22c55e; color: #052e16; }}
        .method-badge.post {{ background: #3b82f6; color: white; }}
        .method-badge.put {{ background: #f59e0b; color: #422006; }}
        .method-badge.delete {{ background: #ef4444; color: white; }}
        .method-badge.patch {{ background: #8b5cf6; color: white; }}
        
        .confidence {{
            color: #a0a0c0;
            font-size: 11px;
        }}
        
        .modal-footer {{
            padding: 16px 24px;
            border-top: 1px solid #2a2a4e;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }}
        .btn {{
            padding: 10px 24px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            border: none;
        }}
        .btn-cancel {{ background: #4a4a7e; color: white; }}
        .btn-save {{ background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; }}
        .btn:disabled {{ opacity: 0.5; cursor: not-allowed; }}
        
        .empty-state {{
            text-align: center;
            padding: 60px 20px;
            color: #6b7280;
        }}
        .stats {{
            display: flex;
            gap: 20px;
            margin-bottom: 16px;
            font-size: 13px;
            color: #a0a0c0;
        }}
        .stat-value {{ color: white; font-weight: 600; }}
    </style>
</head>
<body>
    <div class="header">
        <div>
            <h1>üîç API Discovery</h1>
            <div class="subtitle">{project.name} - Discover API paths per server</div>
        </div>
        <a href="javascript:history.back()" class="back-btn">‚Üê Back</a>
    </div>
    
    <div class="container">
        <div class="stats">
            <div><span class="stat-value">{len(servers)}</span> servers discovered</div>
        </div>
        
        <table class="server-table">
            <thead>
                <tr>
                    <th style="width: 55%;">Server URL</th>
                    <th style="width: 15%;">Level</th>
                    <th style="width: 30%;">Action</th>
                </tr>
            </thead>
            <tbody id="serverTableBody">
            </tbody>
        </table>
    </div>
    
    <!-- Modal -->
    <div class="modal-overlay" id="modal">
        <div class="modal">
            <div class="modal-header">
                <h2 id="modalTitle">ü§ñ AI Discovery</h2>
                <div class="server" id="modalServer"></div>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Dynamic content -->
            </div>
            <div class="modal-footer" id="modalFooter">
                <button class="btn btn-cancel" onclick="closeModal()">Cancel</button>
                <button class="btn btn-save" id="saveBtn" onclick="saveResults()" disabled>Save as Swagger</button>
            </div>
        </div>
    </div>
    
    <script>
        const servers = {servers_json};
        let currentServerIdx = null;
        let discoveredPaths = [];
        
        function renderTable() {{
            const tbody = document.getElementById('serverTableBody');
            if (servers.length === 0) {{
                tbody.innerHTML = `<tr><td colspan="3" class="empty-state">No servers discovered. Run an API scan first.</td></tr>`;
                return;
            }}
            
            tbody.innerHTML = servers.map((url, idx) => `
                <tr>
                    <td><span class="server-url">${{url}}</span></td>
                    <td>
                        <select class="level-select" id="level-${{idx}}">
                            <option value="light">Light</option>
                            <option value="medium" selected>Medium</option>
                            <option value="full">Full</option>
                        </select>
                    </td>
                    <td>
                        <button class="discover-btn" onclick="startDiscovery(${{idx}})">
                            ü§ñ AI Discover
                        </button>
                    </td>
                </tr>
            `).join('');
        }}
        
        function openModal(serverUrl) {{
            document.getElementById('modalServer').textContent = serverUrl;
            document.getElementById('modal').classList.add('active');
        }}
        
        function closeModal() {{
            document.getElementById('modal').classList.remove('active');
            currentServerIdx = null;
            discoveredPaths = [];
        }}
        
        function showProgress(message) {{
            document.getElementById('modalBody').innerHTML = `
                <div class="progress-section">
                    <div class="spinner"></div>
                    <div class="progress-text">${{message}}</div>
                </div>
            `;
            document.getElementById('saveBtn').disabled = true;
        }}
        
        function showResults(paths, stats) {{
            discoveredPaths = paths;
            
            if (paths.length === 0) {{
                document.getElementById('modalBody').innerHTML = `
                    <div class="empty-state">
                        <p>No API paths discovered.</p>
                        <p style="font-size: 12px;">Try increasing the scan level or checking if the server is reachable.</p>
                    </div>
                `;
                document.getElementById('saveBtn').disabled = true;
                return;
            }}
            
            const tableRows = paths.map(p => `
                <tr>
                    <td><span class="method-badge ${{p.method.toLowerCase()}}">${{p.method}}</span></td>
                    <td style="font-family: monospace; font-size: 12px;">${{p.path}}</td>
                    <td><span class="confidence">${{(p.confidence * 100).toFixed(0)}}%</span></td>
                    <td style="font-size: 11px; color: #6b7280;">${{p.source || 'ai'}}</td>
                </tr>
            `).join('');
            
            document.getElementById('modalBody').innerHTML = `
                <div class="stats">
                    <div><span class="stat-value">${{paths.length}}</span> paths discovered</div>
                    <div><span class="stat-value">${{stats.probe_hits || 0}}</span> probe hits</div>
                </div>
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Path</th>
                            <th>Confidence</th>
                            <th>Source</th>
                        </tr>
                    </thead>
                    <tbody>${{tableRows}}</tbody>
                </table>
            `;
            
            document.getElementById('saveBtn').disabled = false;
        }}
        
        async function startDiscovery(idx) {{
            currentServerIdx = idx;
            const serverUrl = servers[idx];
            const level = document.getElementById(`level-${{idx}}`).value;
            
            openModal(serverUrl);
            showProgress(`Probing server (${{level}} mode)...`);
            
            try {{
                const response = await fetch('/projects/{project_id}/api-audit/ai-discover', {{
                    method: 'POST',
                    headers: {{ 'Content-Type': 'application/json' }},
                    body: JSON.stringify({{ server_url: serverUrl, level: level }})
                }});
                
                const result = await response.json();
                
                if (result.success) {{
                    // Get combined paths from the response
                    const paths = result.combined_paths || [];
                    showResults(paths, {{
                        probe_hits: result.probe_hits || 0,
                        ai_paths: result.ai_paths || 0
                    }});
                }} else {{
                    document.getElementById('modalBody').innerHTML = `
                        <div class="empty-state" style="color: #ef4444;">
                            <p>Discovery failed</p>
                            <p style="font-size: 12px;">${{result.error || 'Unknown error'}}</p>
                        </div>
                    `;
                }}
            }} catch (e) {{
                document.getElementById('modalBody').innerHTML = `
                    <div class="empty-state" style="color: #ef4444;">
                        <p>Request failed</p>
                        <p style="font-size: 12px;">${{e.message}}</p>
                    </div>
                `;
            }}
        }}
        
        async function saveResults() {{
            if (currentServerIdx === null || discoveredPaths.length === 0) return;
            
            const serverUrl = servers[currentServerIdx];
            document.getElementById('saveBtn').disabled = true;
            document.getElementById('saveBtn').textContent = 'Saving...';
            
            try {{
                const response = await fetch('/projects/{project_id}/api-audit/save-server-swagger', {{
                    method: 'POST',
                    headers: {{ 'Content-Type': 'application/json' }},
                    body: JSON.stringify({{ 
                        server_url: serverUrl,
                        paths: discoveredPaths
                    }})
                }});
                
                const result = await response.json();
                
                if (result.success) {{
                    alert(`‚úì Swagger saved!\\n\\nFile: ${{result.filename}}\\n\\nYou can now test these paths in SwaggerUI.`);
                    closeModal();
                }} else {{
                    alert('Failed to save: ' + (result.error || 'Unknown error'));
                    document.getElementById('saveBtn').textContent = 'Save as Swagger';
                    document.getElementById('saveBtn').disabled = false;
                }}
            }} catch (e) {{
                alert('Error: ' + e.message);
                document.getElementById('saveBtn').textContent = 'Save as Swagger';
                document.getElementById('saveBtn').disabled = false;
            }}
        }}
        
        renderTable();
    </script>
</body>
</html>'''
    
    return HTMLResponse(content=html_content)


@router.post("/{project_id}/api-audit/save-server-swagger")
async def save_server_swagger(project_id: str, request_data: dict, db: Session = Depends(get_db)):
    """
    Save discovered paths as a Swagger file for a specific server.
    """
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    server_url = request_data.get('server_url', '').strip()
    paths = request_data.get('paths', [])
    
    if not server_url:
        return {"success": False, "error": "Missing server_url"}
    
    if not paths:
        return {"success": False, "error": "No paths to save"}
    
    # Create OpenAPI spec for this server
    from urllib.parse import urlparse
    parsed = urlparse(server_url)
    server_name = parsed.netloc.replace('.', '_').replace(':', '_')
    
    spec = {
        "openapi": "3.0.3",
        "info": {
            "title": f"API - {parsed.netloc}",
            "version": "1.0.0",
            "description": f"Discovered API spec for {server_url}"
        },
        "servers": [{"url": server_url, "description": "Target server"}],
        "paths": {}
    }
    
    # Add paths
    for path_info in paths:
        path = path_info.get('path', '')
        method = path_info.get('method', 'GET').lower()
        if not path or not path.startswith('/'):
            continue
        
        if path not in spec['paths']:
            spec['paths'][path] = {}
        
        spec['paths'][path][method] = {
            "summary": path_info.get('description', f"Discovered endpoint"),
            "responses": {"200": {"description": "Success"}},
            "x-confidence": path_info.get('confidence', 0.5),
            "x-source": path_info.get('source', 'ai')
        }
    
    # Save to file
    reports_dir = os.environ.get("REPORTS_DIR", "/app/vulnerability_reports")
    project_dir = os.path.join(reports_dir, project.name)
    os.makedirs(project_dir, exist_ok=True)
    
    filename = f"{server_name}_swagger.yaml"
    filepath = os.path.join(project_dir, filename)
    
    try:
        with open(filepath, 'w') as f:
            yaml.dump(spec, f, default_flow_style=False)
        
        # Also save JSON version
        json_path = os.path.join(project_dir, f"{server_name}_swagger.json")
        with open(json_path, 'w') as f:
            json.dump(spec, f, indent=2)
        
        return {
            "success": True,
            "filename": filename,
            "path_count": len(spec['paths']),
            "filepath": filepath
        }
    except Exception as e:
        return {"success": False, "error": str(e)}

@router.post("/{project_id}/api-audit/ai-discover")
async def ai_discover_paths(project_id: str, request_data: dict, db: Session = Depends(get_db)):
    """
    AI-powered API path discovery.
    Combines code analysis, server probing, and LLM inference.
    """
    from pathlib import Path as PathlibPath
    
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    server_url = request_data.get('server_url', '').strip()
    level = request_data.get('level', 'medium')
    
    if not server_url:
        return {"success": False, "error": "Missing server_url"}
    
    if level not in ['light', 'medium', 'full']:
        level = 'medium'
    
    # Load existing data
    reports_dir = os.environ.get("REPORTS_DIR", "/app/vulnerability_reports")
    endpoints_file = os.path.join(reports_dir, project.name, f"{project.name}_api_endpoints.json")
    openapi_file = os.path.join(reports_dir, project.name, f"{project.name}_openapi.yaml")
    openapi_json = os.path.join(reports_dir, project.name, f"{project.name}_openapi.json")
    
    # Load credentials for authenticated probing
    credentials = []
    if os.path.exists(endpoints_file):
        try:
            with open(endpoints_file, 'r') as f:
                data = json.load(f)
            for ep in data.get('outbound_endpoints', []):
                secret_type = ep.get('metadata', {}).get('secret_type', '')
                if not secret_type or secret_type == 'api_url':
                    continue
                code = ep.get('code', '')
                value = ''
                if '=' in code:
                    parts = code.split('=', 1)
                    if len(parts) > 1:
                        value = parts[1].strip().strip('"').strip("'")
                if value:
                    credentials.append({
                        'type': secret_type,
                        'value': value[:100],
                        'environment': ep.get('metadata', {}).get('environment', 'unknown'),
                    })
        except:
            pass
    
    # Filter credentials for this server
    matched_creds = [c for c in credentials if _match_credential_to_server(c, server_url)]
    
    # Try to import and run AI discovery
    try:
        import sys
        sys.path.insert(0, '/app/execution')
        from ai_api_discovery import discover_api_paths
        
        result = await discover_api_paths(
            project_id=project_id,
            project_name=project.name,
            server_url=server_url,
            level=level,
            credentials=matched_creds,
            repo_path=None  # Code already scanned, use existing clues
        )
        
        # Count results
        probe_hits = len([p for p in result.get('probe_results', []) if p.get('exists')])
        ai_paths = len(result.get('ai_paths', []))
        combined_paths = result.get('combined_paths', [])
        
        # Update OpenAPI spec with discovered paths
        paths_added = 0
        base_spec = {"openapi": "3.0.3", "info": {"title": f"{project.name} API", "version": "1.0.0"}, "paths": {}, "servers": []}
        
        if os.path.exists(openapi_file):
            try:
                with open(openapi_file, 'r') as f:
                    base_spec = yaml.safe_load(f) or base_spec
            except:
                pass
        
        # Add discovered paths
        for path_info in combined_paths:
            path = path_info.get('path', '')
            method = path_info.get('method', 'GET').lower()
            if not path or not path.startswith('/'):
                continue
            
            if path not in base_spec.get('paths', {}):
                base_spec['paths'][path] = {}
            
            if method not in base_spec['paths'][path]:
                base_spec['paths'][path][method] = {
                    "summary": path_info.get('description', f"Discovered via AI ({path_info.get('source', 'unknown')})"),
                    "responses": {"200": {"description": "Success"}},
                    "x-discovered-by": path_info.get('source', 'ai'),
                    "x-confidence": path_info.get('confidence', 0.5)
                }
                paths_added += 1
        
        # Save updated spec
        if paths_added > 0:
            try:
                with open(openapi_file, 'w') as f:
                    yaml.dump(base_spec, f, default_flow_style=False)
                with open(openapi_json, 'w') as f:
                    json.dump(base_spec, f, indent=2)
            except Exception as e:
                result['errors'] = result.get('errors', []) + [f"Failed to save spec: {e}"]
        
        return {
            "success": True,
            "paths_discovered": paths_added,
            "probe_hits": probe_hits,
            "ai_paths": ai_paths,
            "total_paths": len(base_spec.get('paths', {})),
            "level": level,
            "combined_paths": combined_paths,
            "errors": result.get('errors', [])
        }
        
    except ImportError as e:
        return {"success": False, "error": f"AI discovery module not available: {e}"}
    except Exception as e:
        return {"success": False, "error": str(e)[:200]}


@router.post("/{project_id}/api-audit/spider-server")
async def spider_single_server(project_id: str, request_data: dict, db: Session = Depends(get_db)):
    """
    Spider a single server for OpenAPI specification.
    Updates the project's OpenAPI spec with discovered paths.
    """
    import httpx
    
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    server_url = request_data.get('server_url', '').strip()
    if not server_url:
        return {"success": False, "error": "Missing server_url"}
    
    # Load existing data
    reports_dir = os.environ.get("REPORTS_DIR", "/app/vulnerability_reports")
    endpoints_file = os.path.join(reports_dir, project.name, f"{project.name}_api_endpoints.json")
    openapi_file = os.path.join(reports_dir, project.name, f"{project.name}_openapi.yaml")
    openapi_json = os.path.join(reports_dir, project.name, f"{project.name}_openapi.json")
    
    # Load credentials
    credentials = []
    if os.path.exists(endpoints_file):
        try:
            with open(endpoints_file, 'r') as f:
                data = json.load(f)
            for ep in data.get('outbound_endpoints', []):
                secret_type = ep.get('metadata', {}).get('secret_type', '')
                if not secret_type or secret_type == 'api_url':
                    continue
                code = ep.get('code', '')
                value = ''
                if '=' in code:
                    parts = code.split('=', 1)
                    if len(parts) > 1:
                        value = parts[1].strip().strip('"').strip("'")
                if value:
                    credentials.append({
                        'type': secret_type,
                        'value': value[:100],
                        'environment': ep.get('metadata', {}).get('environment', 'unknown'),
                    })
        except:
            pass
    
    # Find matching credential
    matched_cred = None
    for c in credentials:
        if _match_credential_to_server(c, server_url):
            matched_cred = c
            break
    
    # Build headers
    headers = {"User-Agent": "AuditGH-Spider/1.0"}
    if matched_cred:
        cred_type = matched_cred.get('type', '').lower()
        cred_value = matched_cred.get('value', '')
        if 'azure' in cred_type:
            headers['Ocp-Apim-Subscription-Key'] = cred_value
        elif 'bearer' in cred_type or 'token' in cred_type:
            headers['Authorization'] = f'Bearer {cred_value}'
        else:
            headers['X-API-Key'] = cred_value
    
    # Probe common OpenAPI paths
    spider_paths = ['/swagger.json', '/openapi.json', '/api-docs', '/v3/api-docs', '/v2/api-docs', '/swagger.yaml', '/openapi.yaml']
    discovered_spec = None
    source_url = None
    
    async with httpx.AsyncClient(timeout=10.0, follow_redirects=True) as client:
        for path in spider_paths:
            try:
                url = server_url.rstrip('/') + path
                resp = await client.get(url, headers=headers)
                if resp.status_code == 200:
                    try:
                        spec = resp.json()
                        if 'paths' in spec or 'openapi' in spec or 'swagger' in spec:
                            discovered_spec = spec
                            source_url = url
                            break
                    except:
                        # Try YAML
                        try:
                            spec = yaml.safe_load(resp.text)
                            if isinstance(spec, dict) and ('paths' in spec or 'openapi' in spec):
                                discovered_spec = spec
                                source_url = url
                                break
                        except:
                            pass
            except:
                pass
    
    if not discovered_spec:
        return {"success": True, "paths_found": 0, "message": "No OpenAPI spec found"}
    
    # Load existing spec
    base_spec = {"openapi": "3.0.3", "info": {"title": f"{project.name} API", "version": "1.0.0"}, "paths": {}, "servers": []}
    if os.path.exists(openapi_file):
        try:
            with open(openapi_file, 'r') as f:
                base_spec = yaml.safe_load(f) or base_spec
        except:
            pass
    
    # Merge discovered paths
    paths_added = 0
    for path, methods in discovered_spec.get('paths', {}).items():
        if path not in base_spec.get('paths', {}):
            base_spec['paths'][path] = methods
            paths_added += len([m for m in methods.keys() if m.lower() in ['get', 'post', 'put', 'delete', 'patch']])
    
    # Save updated spec
    try:
        with open(openapi_file, 'w') as f:
            yaml.dump(base_spec, f, default_flow_style=False)
        with open(openapi_json, 'w') as f:
            json.dump(base_spec, f, indent=2)
    except Exception as e:
        return {"success": False, "error": str(e)}
    
    return {
        "success": True,
        "paths_found": paths_added,
        "source_url": source_url,
        "total_paths": len(base_spec.get('paths', {}))
    }


@router.post("/{project_id}/api-audit/test-auth")
async def test_server_authorization(project_id: str, request_data: dict, db: Session = Depends(get_db)):
    """
    Test authorization against a server with the provided credential.
    Makes a HEAD request to the server with appropriate auth headers.
    """
    import httpx
    
    server_url = request_data.get('server_url', '')
    cred_type = request_data.get('credential_type', '').lower()
    cred_value = request_data.get('credential_value', '')
    
    if not server_url or not cred_value:
        return {"success": False, "error": "Missing params"}
    
    # Build headers based on credential type
    headers = {"User-Agent": "AuditGH-API-Tester/1.0"}
    
    if 'bearer' in cred_type or 'token' in cred_type:
        headers['Authorization'] = f'Bearer {cred_value}'
    elif 'azure' in cred_type or 'subscription' in cred_type:
        headers['Ocp-Apim-Subscription-Key'] = cred_value
    elif 'api_key' in cred_type:
        headers['X-API-Key'] = cred_value
    elif 'mixpanel' in cred_type:
        import base64
        headers['Authorization'] = f'Basic {base64.b64encode(f"{cred_value}:".encode()).decode()}'
    else:
        headers['Authorization'] = f'Bearer {cred_value}'
    
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.head(server_url, headers=headers, follow_redirects=True)
            
            # Consider 2xx, 3xx, 401, 403 as "connectivity" successes (server responded)
            if response.status_code < 500:
                return {
                    "success": response.status_code < 400,
                    "status_code": response.status_code,
                    "message": "Auth accepted" if response.status_code < 400 else "Auth rejected"
                }
            else:
                return {"success": False, "status_code": response.status_code, "error": "Server error"}
    except httpx.TimeoutException:
        return {"success": False, "error": "Timeout"}
    except httpx.RequestError as e:
        return {"success": False, "error": str(type(e).__name__)}
    except Exception as e:
        return {"success": False, "error": str(e)[:50]}


@router.get("/{project_id}/api-audit/server/{server_index}/swagger", response_class=HTMLResponse)
def get_server_swagger_ui(project_id: str, server_index: int, db: Session = Depends(get_db)):
    """
    Per-server SwaggerUI with pre-filled auth credentials.
    Shows only the paths for this specific server with auth already configured.
    """
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Load data
    reports_dir = os.environ.get("REPORTS_DIR", "/app/vulnerability_reports")
    endpoints_file = os.path.join(reports_dir, project.name, f"{project.name}_api_endpoints.json")
    openapi_file = os.path.join(reports_dir, project.name, f"{project.name}_openapi.yaml")
    
    servers = []
    credentials = []
    
    # Load servers from OpenAPI
    if os.path.exists(openapi_file):
        try:
            with open(openapi_file, 'r') as f:
                spec = yaml.safe_load(f)
                for s in spec.get('servers', []):
                    servers.append(s.get('url', ''))
        except:
            pass
    
    if server_index >= len(servers):
        raise HTTPException(status_code=404, detail="Server not found")
    
    server_url = servers[server_index]
    
    # Load credentials
    if os.path.exists(endpoints_file):
        try:
            with open(endpoints_file, 'r') as f:
                data = json.load(f)
            
            for ep in data.get('outbound_endpoints', []):
                secret_type = ep.get('metadata', {}).get('secret_type', '')
                if not secret_type or secret_type == 'api_url':
                    continue
                
                code = ep.get('code', '')
                value = ''
                if '=' in code:
                    parts = code.split('=', 1)
                    if len(parts) > 1:
                        value = parts[1].strip().strip('"').strip("'")
                
                if value:
                    credentials.append({
                        'type': secret_type,
                        'name': ep.get('metadata', {}).get('key_name', secret_type),
                        'value': value[:100],
                        'environment': ep.get('metadata', {}).get('environment', 'unknown'),
                    })
        except:
            pass
    
    # Match credentials to this server
    matched_creds = [c for c in credentials if _match_credential_to_server(c, server_url)]
    
    # Determine auth type for this server
    auth_type = 'none'
    auth_value = ''
    auth_scheme_name = 'apiKey'
    
    if matched_creds:
        cred = matched_creds[0]  # Use first matching credential
        cred_type = cred.get('type', '').lower()
        auth_value = cred.get('value', '')
        
        if 'azure' in cred_type or 'subscription' in cred_type:
            auth_type = 'apiKey'
            auth_scheme_name = 'AzureSubscription'
        elif 'bearer' in cred_type or 'jwt' in cred_type or 'token' in cred_type:
            auth_type = 'bearer'
            auth_scheme_name = 'BearerAuth'
        elif 'basic' in cred_type or 'mixpanel' in cred_type:
            auth_type = 'basic'
            auth_scheme_name = 'BasicAuth'
        else:
            auth_type = 'apiKey'
            auth_scheme_name = 'ApiKey'
    
    # Build mini OpenAPI spec for this server
    server_spec = {
        "openapi": "3.0.3",
        "info": {
            "title": f"API Explorer - {urlparse(server_url).netloc}",
            "version": "1.0.0",
            "description": f"Discovered API server from {project.name}"
        },
        "servers": [{"url": server_url, "description": "Discovered server"}],
        "paths": {
            "/": {
                "get": {
                    "summary": "Health Check",
                    "description": "Check server connectivity and authentication",
                    "operationId": "healthCheck",
                    "responses": {"200": {"description": "Server is reachable"}}
                }
            },
            "/api": {
                "get": {
                    "summary": "API Root",
                    "description": "Check API root endpoint",
                    "operationId": "apiRoot",
                    "responses": {"200": {"description": "API is available"}}
                }
            }
        },
        "components": {
            "securitySchemes": {}
        }
    }
    
    # Add appropriate security scheme
    if auth_type == 'apiKey':
        if 'azure' in auth_scheme_name.lower():
            server_spec['components']['securitySchemes'][auth_scheme_name] = {
                "type": "apiKey",
                "in": "header",
                "name": "Ocp-Apim-Subscription-Key",
                "description": "Azure API Subscription Key"
            }
        else:
            server_spec['components']['securitySchemes'][auth_scheme_name] = {
                "type": "apiKey",
                "in": "header", 
                "name": "X-API-Key",
                "description": "API Key"
            }
    elif auth_type == 'bearer':
        server_spec['components']['securitySchemes'][auth_scheme_name] = {
            "type": "http",
            "scheme": "bearer",
            "description": "Bearer Token / JWT"
        }
    elif auth_type == 'basic':
        server_spec['components']['securitySchemes'][auth_scheme_name] = {
            "type": "http",
            "scheme": "basic",
            "description": "Basic Authentication"
        }
    
    # Apply security to all paths
    if auth_scheme_name in server_spec['components']['securitySchemes']:
        server_spec['security'] = [{auth_scheme_name: []}]
    
    spec_json = json.dumps(server_spec)
    creds_json = json.dumps(matched_creds)
    
    # Generate HTML with pre-filled auth
    html_content = f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Explorer - {urlparse(server_url).netloc}</title>
    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui.css" />
    <style>
        body {{ margin: 0; padding: 0; background: #1a1a2e; }}
        .header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px 30px;
        }}
        .header h1 {{ margin: 0; font-size: 1.3rem; font-family: system-ui; }}
        .header .server {{ opacity: 0.85; font-size: 0.85rem; font-family: monospace; margin-top: 4px; }}
        .auth-bar {{
            background: #22223a;
            padding: 12px 30px;
            border-bottom: 1px solid #3a3a6e;
            font-family: system-ui;
        }}
        .auth-bar label {{ color: #a0a0c0; font-size: 12px; display: block; margin-bottom: 4px; }}
        .auth-bar .auth-row {{ display: flex; gap: 12px; align-items: flex-end; flex-wrap: wrap; }}
        .auth-field {{ }}
        .auth-field input, .auth-field select {{
            background: #1a1a2e;
            border: 1px solid #4a4a7e;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            min-width: 200px;
        }}
        .auth-field input:focus {{ outline: none; border-color: #667eea; }}
        .auth-btn {{
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
        }}
        .auth-status {{
            color: #10b981;
            font-size: 12px;
            padding: 8px 12px;
        }}
        .auth-status.warning {{ color: #f59e0b; }}
        .swagger-ui .topbar {{ display: none; }}
        .swagger-ui {{ max-width: 1400px; margin: 0 auto; }}
        .back-link {{
            color: rgba(255,255,255,0.7);
            text-decoration: none;
            font-size: 13px;
            margin-left: 20px;
        }}
        .back-link:hover {{ color: white; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>
            üîç API Explorer
            <a href="javascript:history.back()" class="back-link">‚Üê Back</a>
        </h1>
        <div class="server">{server_url}</div>
    </div>
    
    <div class="auth-bar">
        <div class="auth-row">
            <div class="auth-field">
                <label>Authentication Type</label>
                <select id="authType" onchange="updateAuthFields()">
                    <option value="apiKey" {"selected" if auth_type == "apiKey" else ""}>API Key (Header)</option>
                    <option value="bearer" {"selected" if auth_type == "bearer" else ""}>Bearer Token / JWT</option>
                    <option value="basic" {"selected" if auth_type == "basic" else ""}>Basic Auth</option>
                </select>
            </div>
            
            <div class="auth-field" id="apiKeyField" style="display: {"block" if auth_type == "apiKey" else "none"}">
                <label>API Key Value</label>
                <input type="text" id="apiKeyValue" value="{auth_value if auth_type == 'apiKey' else ''}" placeholder="Enter API key..." />
            </div>
            
            <div class="auth-field" id="bearerField" style="display: {"block" if auth_type == "bearer" else "none"}">
                <label>Bearer Token</label>
                <input type="text" id="bearerValue" value="{auth_value if auth_type == 'bearer' else ''}" placeholder="Enter token..." />
            </div>
            
            <div class="auth-field" id="basicUserField" style="display: {"block" if auth_type == "basic" else "none"}">
                <label>Username</label>
                <input type="text" id="basicUsername" value="{auth_value if auth_type == 'basic' else ''}" placeholder="Username..." />
            </div>
            
            <div class="auth-field" id="basicPassField" style="display: {"block" if auth_type == "basic" else "none"}">
                <label>Password</label>
                <input type="password" id="basicPassword" placeholder="Password..." />
            </div>
            
            <button class="auth-btn" onclick="applyAuth()">üîë Apply Authorization</button>
            <span class="auth-status" id="authStatus">{"‚úì Pre-filled with discovered credential" if auth_value else "‚ö† No credential discovered"}</span>
        </div>
    </div>
    
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-bundle.js"></script>
    <script>
        const spec = {spec_json};
        const credentials = {creds_json};
        let swaggerUI = null;
        
        function updateAuthFields() {{
            const authType = document.getElementById('authType').value;
            document.getElementById('apiKeyField').style.display = authType === 'apiKey' ? 'block' : 'none';
            document.getElementById('bearerField').style.display = authType === 'bearer' ? 'block' : 'none';
            document.getElementById('basicUserField').style.display = authType === 'basic' ? 'block' : 'none';
            document.getElementById('basicPassField').style.display = authType === 'basic' ? 'block' : 'none';
        }}
        
        function applyAuth() {{
            const status = document.getElementById('authStatus');
            status.textContent = '‚úì Authorization applied';
            status.className = 'auth-status';
            
            // Re-init SwaggerUI with new auth
            initSwaggerUI();
        }}
        
        function initSwaggerUI() {{
            const authType = document.getElementById('authType').value;
            let authHeader = '';
            
            if (authType === 'apiKey') {{
                authHeader = document.getElementById('apiKeyValue').value;
            }} else if (authType === 'bearer') {{
                authHeader = 'Bearer ' + document.getElementById('bearerValue').value;
            }} else if (authType === 'basic') {{
                const user = document.getElementById('basicUsername').value;
                const pass = document.getElementById('basicPassword').value;
                authHeader = 'Basic ' + btoa(user + ':' + pass);
            }}
            
            if (document.getElementById('swagger-ui')) {{
                document.getElementById('swagger-ui').innerHTML = '';
            }}
            
            swaggerUI = SwaggerUIBundle({{
                spec: spec,
                dom_id: '#swagger-ui',
                deepLinking: true,
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIBundle.SwaggerUIStandalonePreset
                ],
                layout: "BaseLayout",
                defaultModelsExpandDepth: -1,
                docExpansion: "list",
                tryItOutEnabled: true,
                
                requestInterceptor: function(request) {{
                    if (authHeader) {{
                        const authType = document.getElementById('authType').value;
                        if (authType === 'apiKey') {{
                            // Detect Azure vs generic API key
                            if ('{server_url}'.includes('azure')) {{
                                request.headers['Ocp-Apim-Subscription-Key'] = authHeader;
                            }} else {{
                                request.headers['X-API-Key'] = authHeader;
                            }}
                        }} else {{
                            request.headers['Authorization'] = authHeader;
                        }}
                    }}
                    return request;
                }}
            }});
        }}
        
        window.onload = initSwaggerUI;
    </script>
</body>
</html>'''
    
    return HTMLResponse(content=html_content)


@router.post("/{project_id}/api-audit/spider-openapi")
async def spider_openapi_specs(project_id: str, db: Session = Depends(get_db)):
    """
    Spider discovered servers for OpenAPI specifications.
    Updates the project's OpenAPI spec with discovered paths and methods.
    """
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Load data
    reports_dir = os.environ.get("REPORTS_DIR", "/app/vulnerability_reports")
    endpoints_file = os.path.join(reports_dir, project.name, f"{project.name}_api_endpoints.json")
    openapi_file = os.path.join(reports_dir, project.name, f"{project.name}_openapi.yaml")
    openapi_json = os.path.join(reports_dir, project.name, f"{project.name}_openapi.json")
    
    servers = []
    credentials = []
    
    # Load servers from OpenAPI
    base_spec = {"openapi": "3.0.3", "info": {"title": f"{project.name} API", "version": "1.0.0"}, "paths": {}, "servers": []}
    if os.path.exists(openapi_file):
        try:
            with open(openapi_file, 'r') as f:
                base_spec = yaml.safe_load(f)
                for s in base_spec.get('servers', []):
                    servers.append(s.get('url', ''))
        except:
            pass
    
    # Load credentials
    if os.path.exists(endpoints_file):
        try:
            with open(endpoints_file, 'r') as f:
                data = json.load(f)
            
            for ep in data.get('outbound_endpoints', []):
                secret_type = ep.get('metadata', {}).get('secret_type', '')
                if not secret_type or secret_type == 'api_url':
                    continue
                
                code = ep.get('code', '')
                value = ''
                if '=' in code:
                    parts = code.split('=', 1)
                    if len(parts) > 1:
                        value = parts[1].strip().strip('"').strip("'")
                
                if value:
                    credentials.append({
                        'type': secret_type,
                        'value': value[:100],
                        'environment': ep.get('metadata', {}).get('environment', 'unknown'),
                    })
        except:
            pass
    
    # Build credentials map
    creds_map = {}
    for server in servers:
        matched = [c for c in credentials if _match_credential_to_server(c, server)]
        if matched:
            creds_map[server] = matched[0]
    
    # Spider servers (limit to first 5 for speed)
    discovered_specs = {}
    import httpx
    
    async with httpx.AsyncClient(timeout=10.0, follow_redirects=True) as client:
        for server_url in servers[:5]:
            creds = creds_map.get(server_url)
            headers = {"User-Agent": "AuditGH-Spider/1.0"}
            
            if creds:
                cred_type = creds.get('type', '').lower()
                cred_value = creds.get('value', '')
                if 'azure' in cred_type:
                    headers['Ocp-Apim-Subscription-Key'] = cred_value
                elif 'bearer' in cred_type or 'token' in cred_type:
                    headers['Authorization'] = f'Bearer {cred_value}'
                else:
                    headers['X-API-Key'] = cred_value
            
            # Probe common OpenAPI paths
            spider_paths = ['/swagger.json', '/openapi.json', '/api-docs', '/v3/api-docs', '/v2/api-docs']
            for path in spider_paths:
                try:
                    url = server_url.rstrip('/') + path
                    resp = await client.get(url, headers=headers)
                    if resp.status_code == 200:
                        try:
                            spec = resp.json()
                            if 'paths' in spec or 'openapi' in spec or 'swagger' in spec:
                                discovered_specs[server_url] = {
                                    'source_url': url,
                                    'spec': spec
                                }
                                break  # Found spec for this server
                        except:
                            pass
                except:
                    pass
    
    # Merge discovered specs
    merged_paths_count = 0
    for server_url, spec_data in discovered_specs.items():
        spec = spec_data.get('spec', {})
        for path, methods in spec.get('paths', {}).items():
            if path not in base_spec.get('paths', {}):
                base_spec['paths'][path] = methods
                merged_paths_count += len([m for m in methods.keys() if m.lower() in ['get', 'post', 'put', 'delete', 'patch']])
    
    # Save updated spec
    try:
        with open(openapi_file, 'w') as f:
            yaml.dump(base_spec, f, default_flow_style=False)
        with open(openapi_json, 'w') as f:
            json.dump(base_spec, f, indent=2)
    except Exception as e:
        return {"success": False, "error": str(e)}
    
    return {
        "success": True,
        "servers_spidered": len(servers[:5]),
        "specs_found": len(discovered_specs),
        "paths_discovered": merged_paths_count,
        "discovered_from": list(discovered_specs.keys())
    }


from urllib.parse import urlparse


@router.get("/{project_id}/api-audit/openapi/view", response_model=OpenAPISpecResponse)
def view_project_openapi_spec(project_id: str, db: Session = Depends(get_db)):
    """Get the OpenAPI specification content for viewing in UI."""
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    spec = db.query(models.OpenAPISpec).filter(
        models.OpenAPISpec.repository_id == project_id
    ).first()
    
    if not spec:
        raise HTTPException(status_code=404, detail="OpenAPI specification not found")
    
    return OpenAPISpecResponse(
        spec_content=spec.spec_content,
        spec_format=spec.spec_format,
        version=spec.version,
        endpoint_count=spec.endpoint_count,
        generated_at=spec.generated_at
    )


# =============================================================================
# Full Report Endpoint - Returns complete audit data from JSON files
# =============================================================================

import json
import os
import yaml

@router.get("/{project_id}/api-audit/full-report")
def get_project_full_audit_report(project_id: str, db: Session = Depends(get_db)):
    """
    Get the complete API audit report data including:
    - Inbound/outbound endpoints
    - Discovered servers
    - Credential risk assessment (HIGH/MEDIUM/LOW)
    - Fingerprint data
    """
    project = db.query(models.Repository).filter(
        models.Repository.id == project_id
    ).first()
    
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Try to load from vulnerability_reports JSON file
    reports_dir = os.environ.get("REPORTS_DIR", "/app/vulnerability_reports")
    repo_name = project.name
    
    endpoints_file = os.path.join(reports_dir, repo_name, f"{repo_name}_api_endpoints.json")
    openapi_file = os.path.join(reports_dir, repo_name, f"{repo_name}_openapi.yaml")
    fingerprint_file = os.path.join(reports_dir, repo_name, f"{repo_name}_fingerprint.json")
    
    result = {
        "repository": repo_name,
        "timestamp": None,
        "inbound_endpoints": [],
        "outbound_endpoints": [],
        "auth_patterns": [],
        "fingerprint": {
            "language": None,
            "frameworks": [],
            "http_clients": [],
            "config_sources": []
        },
        "servers": [],
        "credentials": {
            "high": [],
            "medium": [],
            "low": []
        }
    }
    
    # Load endpoints JSON
    if os.path.exists(endpoints_file):
        try:
            with open(endpoints_file, 'r') as f:
                data = json.load(f)
                result["timestamp"] = data.get("timestamp")
                result["inbound_endpoints"] = data.get("inbound_endpoints", [])
                result["outbound_endpoints"] = data.get("outbound_endpoints", [])
                result["auth_patterns"] = data.get("auth_patterns", [])
                
                # Classify credentials by risk
                for ep in result["outbound_endpoints"]:
                    secret_type = ep.get("metadata", {}).get("secret_type", "")
                    if not secret_type or secret_type == "api_url":
                        continue
                    
                    cred = {
                        "type": secret_type,
                        "environment": ep.get("metadata", {}).get("environment", "unknown"),
                        "file": os.path.basename(ep.get("path", "")),
                        "code": ep.get("code", "")[:80],
                        "attack_vector": None
                    }
                    
                    # Classify by risk level
                    if any(x in secret_type.lower() for x in ['azure_key', 'shared_key', 'secret', 'signature']):
                        cred["attack_vector"] = "Infrastructure access, service impersonation"
                        result["credentials"]["high"].append(cred)
                    elif any(x in secret_type.lower() for x in ['mixpanel', 'firebase', 'instabug', 'api_key']):
                        if 'mixpanel' in secret_type.lower():
                            cred["attack_vector"] = "Send fake analytics, impersonate users"
                        elif 'firebase' in secret_type.lower():
                            cred["attack_vector"] = "Push notification abuse, Firebase access"
                        elif 'instabug' in secret_type.lower():
                            cred["attack_vector"] = "Submit fake bug reports"
                        else:
                            cred["attack_vector"] = "API abuse, data injection"
                        result["credentials"]["medium"].append(cred)
                    elif any(x in secret_type.lower() for x in ['client_id', 'cognito']):
                        cred["attack_vector"] = "API reconnaissance"
                        result["credentials"]["low"].append(cred)
        except Exception as e:
            print(f"Error loading endpoints file: {e}")
    else:
        # FALLBACK: Load from database if files don't exist
        endpoints = db.query(models.APIEndpoint).filter(
            models.APIEndpoint.repository_id == project_id
        ).all()
        
        for ep in endpoints:
            endpoint_data = {
                "category": "db",
                "rule_id": "database",
                "path": ep.file_path or "",
                "line": ep.line_number or 0,
                "code": ep.code_snippet or ep.endpoint_url,
                "endpoint_path": ep.endpoint_url,
                "message": f"From database: {ep.framework or 'unknown'}",
                "metadata": {
                    "category": "api-discovery",
                    "subcategory": ep.direction,
                    "framework": ep.framework
                }
            }
            if ep.direction == 'serves':
                result["inbound_endpoints"].append(endpoint_data)
            else:
                result["outbound_endpoints"].append(endpoint_data)
    
    # Load OpenAPI spec for servers
    if os.path.exists(openapi_file):
        try:
            with open(openapi_file, 'r') as f:
                spec = yaml.safe_load(f)
                result["servers"] = spec.get("servers", [])
        except Exception as e:
            print(f"Error loading OpenAPI file: {e}")
    else:
        # FALLBACK: Load from database
        spec = db.query(models.OpenAPISpec).filter(
            models.OpenAPISpec.repository_id == project_id
        ).first()
        if spec:
            try:
                spec_data = yaml.safe_load(spec.spec_content) if spec.spec_format == 'yaml' else json.loads(spec.spec_content)
                result["servers"] = spec_data.get("servers", [])
            except:
                pass
    
    # Load fingerprint
    if os.path.exists(fingerprint_file):
        try:
            with open(fingerprint_file, 'r') as f:
                fp = json.load(f)
                result["fingerprint"] = fp
        except Exception as e:
            print(f"Error loading fingerprint file: {e}")
    
    return result

